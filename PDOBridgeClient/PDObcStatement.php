<?php

class PDObcStatement implements Iterator{
	
	private $pdobc_object;
	
	/**
	 *The SQL statement we're executing
	 * @var string
	 */
	private $statement;
	
	/**
	 * The raw results from the executed query
	 * @var array
	 */
	private $resultSet = array();
	
	/**
	 * This is the result set to be used when the class is iterated upon
	 * This is generated by the rewind() method via fetchAll()
	 * @var type 
	 */
	private $fetchedResultSet = array();
	
	/**
	 * Keeps track of the current position in the result set
	 * @var int
	 */
	private $resultSetPointer = 0;
	
	/**
	 * The fetch mode to be used
	 * @var int
	 */
	private $fetchMode;
	
	/**
	 * Which column number to fetch if set via fetchMode()
	 * @var int 
	 */
	private $fetchColNo = 0;
	
	/**
	 * The name of the class to initiate with the results
	 * @var string 
	 */
	private $fetchClassName;
	
	/**
	 * The name of the function to call with the results
	 * @var string 
	 */
	private $fetchFunctionName;
	
	/**
	 * The $ctoargs argument used in fetchMode()
	 * @var array 
	 */
	private $fetchCtoargs;
	
	/**
	 * The object to fetch junk into as used in fetchMode()
	 * @var array 
	 */
	private $fetchObject;
	
	/**
	 * Array of references to bind results to
	 * @var type 
	 */
	private $bindReferences = array();
	
	/**
	 * List of input parameters
	 * @var array
	 */
	private $inputParameters = array();
	

	public function __construct($pdobc_object, $statement){
		$this->pdobc_object = $pdobc_object;
		$this->statement = $statement;
		$this->fetchMode = PDO::FETCH_BOTH;
	}
	
	/**
	 * Bind a value to be used in the statement	
	 * @param type $column
	 * @param type $param
	 * @param type $type
	 * @return bool 
	 */
	public function bindColumn($column, &$param, $type=false){
		$this->bindReferences[$column] = array("reference"=>&$param, "type"=>$type);
		return true;
	}
	
	/**
	 * Bind a parameter to the statement
	 * @param type $parameter
	 * @param type $variable
	 * @param type $data_type
	 * @return bool
	 */
	public function bindParam($parameter, &$variable, $data_type=false){
		if(!$data_type) $data_type = PDO::PARAM_STR;
		switch($data_type){
			case PDO::PARAM_BOOL:
				$inputParameters[$parameter] = !!$variable;
				break;
			case PDO::PARAM_NULL:
				$inputParameters[$parameter] = null;
				break;
			case PDO::PARAM_INT:
				$inputParameters[$parameter] = intval($variable);
				break;
			case PDO::PARAM_STR:
			case PDO::PARAM_LOB:
			default:
				$inputParameters[$parameter] = strval($variable);
				break;
		}
	}
	
	/**
	 * Execute the query
	 * @param type $input_parameters
	 * @return bool
	 */
	public function execute($input_parameters = array()){
		$post_params = [
			'created' => time(),
			'sql' => $this->statement,
			'params' => [],
			'dsn' => $this->pdobc_object->dsn,
			'user' => $this->pdobc_object->user,
			'pass' => $this->pdobc_object->pass
		];
		
		if(!empty($input_parameters)){
			foreach($input_parameters as $k=>$v){
				$this->inputParameters[$k]=$v;
			}
		}
		
		if(!empty($this->inputParameters)){
			foreach($this->inputParameters as $k=>$v){
				$post_params['params'][$k] = $v;
			}
		}
		
		$this->resultSet = array();
		$post_params_json = json_encode($post_params);
		if(false === $post_params_json) $this->error('Couldn\'t encode data');
		$post_params_encoded = $this->encrypt($post_params_json);
		if(false === $post_params_encoded) $this->error('Couldn\'t encrypt data');
		
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->pdobc_object->pdob_host);
		curl_setopt($ch, CURLOPT_POST, 1);
		curl_setopt($ch, CURLOPT_POSTFIELDS, array('data'=>$post_params_encoded));
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		$response = curl_exec($ch);
		if(curl_error($ch)) $this->error(curl_error($ch));
		curl_close($ch);
		
		$raw_response = json_decode($response, true);
		if(false === $raw_response) $this->error('Unintelligible response from host.');
		if(!empty($raw_response['error'])) $this->error($raw_response['error']);
		
		$data = $this->decrypt($raw_response['data']);
		if(false === $data) error('Unable to decrypt server response.');
		$data = json_decode($data, true);
		if(false === $data) error('Unable to decode server response.');
		
		$this->resultSet = $data;
		return true;
	}
	
	/**
	 * Get the next result in the thing
	 * @param type $fetch_style
	 * @param type $cursor_orientation - @todo Support scrollable cursor
	 * @param type $cursor_offset - @todo Support scrollable cursor
	 * @return mixed
	 */
	public function fetch($fetch_style=false, $cursor_orientation=false, $cursor_offset=0){
		if($fetch_style !== false) $this->setFetchMode($fetch_style);
		if($this->resultSetPointer >= count($this->resultSet)) return false;
		$r = $this->resultSet[$this->resultSetPointer];
		$return = true;
		switch($this->fetchMode){
			case PDO::FETCH_CLASS:
			case PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE:
			case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE:
				$className = !empty($this->fetchClassName) ? 
					$this->fetchClassName : array_shift($r);
				if(!is_string($className) || !class_exists($className)){
					$this->error("Class $className does not exist.");
					return false;
				}
				if(empty($this->fetchCtoargs)) $return = new $className;
				else{
					$rc = new ReflectionClass($className);
					$args = empty($this->fetchCtoargs) ? array() : $this->fetchCtoargs;
					$args = !is_array($args) ? array($args) : $args;
					$return = $rc->newInstanceArgs($args);
				}
				foreach($r as $k=>$v) $return->$k = $v;
				break;
			case PDO::FETCH_INTO:
				foreach($r as $k=>$v) $this->fetchObject->$k = $v;
				$return = true;
				break;
			case PDO::FETCH_OBJ:
				$return = new stdClass();
				foreach($r as $k=>$v) $return->$k = $v;
				break;
			case PDO::FETCH_NAMED:
			case PDO::FETCH_ASSOC:
				// @todo properly implement FETCH_NAMED
				$return = $r;
				break;
			case PDO::FETCH_NUM:
				$return = array_values($r);
				break;
			case PDO::FETCH_BOUND:
				$keys = array_keys($r);
				$values = array_values($r);
				foreach($this->bindReferences as $column=>$info){
					$pullfrom = in_array($column, $keys) ? $r : $values;
					if(!isset($pullfrom[$column])){
						$this->error("Illegal offset: $column");
						return false;
					}
					switch($info['type']){
						case "PDO::PARAM_BOOL": $info['reference'] = !!$pullfrom[$column]; break;
						case "PDO::PARAM_NULL": $info['reference'] = null; break;
						case "PDO::PARAM_INT": $info['reference'] = intval($pullfrom[$column]); break;
						case "PDO::PARAM_LOB": case "PDO::PARAM_STR": $info['reference'] = strval($pullfrom[$column]); break;
						default: $info['reference'] = $pullfrom[$column]; break;
					}
				}
				$return = true;
			case PDO::FETCH_BOTH;
				$return = array(); $i=0;
				foreach($r as $k=>$v){
					$return[$k] = $v;
					$return[$i] = $v;
					$i++;
				}
				break;
			case PDO::FETCH_COLUMN:
				if(empty($this->fetchColNo)) $this->fetchColNo = 0;
				$vals = array_values($r);
				if(!isset($vals[$this->fetchColNo])){
					$this->error("Illegal column index: {$this->fetchColNo}");
					return false;
				}
				$return = $vals[$this->fetchColNo];
				break;
			case PDO::FETCH_FUNC:
				if(!function_exists($this->fetchFunctionName)){
					$this->error("Function does not exist: {$this->fetchFunctionName}");
					return false;
				}
				$return = call_user_func_array($this->fetchFunctionName, array_values($r));
				break;
			default: 
				$this->error("Unknown or unsupported Fetch mode");
				return false;
				break;
		}
		$this->resultSetPointer++;
		return $return;
	}
	
	/**
	 * Fetch all the result of the statement
	 * @param type $fetch_style
	 * @param type $fetch_argument
	 * @param type $ctor_args
	 * @return array
	 */
	public function fetchAll($fetch_style=false, &$fetch_argument=false, $ctor_args=array()){
		if(false !== $fetch_style) $this->setFetchMode($fetch_style, $fetch_argument, $ctor_args);
		$this->fetchedResultSet = array();
		while($res = $this->fetch()){
			if(is_bool($res)) return $res;
			array_push($this->fetchedResultSet, $res);
		}
		return $this->fetchedResultSet;
	}
	
	/**
	 * Set the fetch mode
	 * Note: When using FETCH_CLASS, it is always treated as though FETCH_PROPS_LATE
	 * is also given. I cannot emulate FETCH_CLASS without FETCH_PROPS_LATE.
	 * Note: Using FETCH_LAZY and FETCH_OBJ will return  an instance of stdClass 
	 * rather than an anonymous object
	 * @param int $mode
	 * @param mixed $param
	 * @param array $ctoargs
	 * @return boolean
	 */
	public function setFetchMode($mode, &$param=false, $ctoargs=array()){
		switch($mode){
			case PDO::FETCH_CLASS:
			case PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE:
			case PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE:
				if(empty($param)) $param = "stdClass";
				if(!is_string($param) || !class_exists($param) && PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE !== $mode){
					$this->error("Class $param does not exist.");
					return false;
				}
				$this->fetchMode = PDO::FETCH_CLASS;
				$this->fetchColNo = 0;
				$this->fetchClassName = $param;
				$this->fetchCtoargs = $ctoargs;
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case PDO::FETCH_INTO:
				if(!is_object($param)) $param = new stdClass();
				$this->fetchMode = PDO::FETCH_INTO;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = &$param;
				$this->fetchFunctionName = "";
				break;
			case PDO::FETCH_LAZY:
			case PDO::FETCH_OBJ:
			case PDO::FETCH_NAMED:
			case PDO::FETCH_NUM:
			case PDO::FETCH_BOUND:
			case PDO::FETCH_BOTH;
			case PDO::FETCH_ASSOC:
				$this->fetchMode = $mode;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case PDO::FETCH_COLUMN:
				$this->fetchMode = $mode;
				$this->fetchColNo = $param;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case PDO::FETCH_FUNC:
				if(!function_exists($param)){
					$this->error("Function does not exist: {$param}");
					return false;
				}
				$this->fetchMode = $mode;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = $param;
				break;
			default: 
				$this->error("Unknown fetch mode: $mode");
				return false;
				break;
		}
		return true;
	}
	
	//--------------------------------------------------------------------------
	// Helpers
	//--------------------------------------------------------------------------
	
	/**
	 * Throws an error
	 */
	public function error($msg){
		trigger_error(htmlentities($msg, ENT_QUOTES), E_USER_ERROR);
	}
	
	//--------------------------------------------------------------------------
	// Iterator methods
	//--------------------------------------------------------------------------
	
	public function rewind() {
		$this->fetchAll();
        $this->resultSetPointer = 0;
    }
	
	public function current() {
        return $this->fetchedResultSet[$this->resultSetPointer];
    }

    public function key() {
        return $this->resultSetPointer;
    }

    public function next() {
        $this->resultSetPointer++;
    }

    public function valid() {
        return isset($this->fetchedResultSet[$this->resultSetPointer]);
    }
	
	private function encrypt($string){ 
		$encryption_iv = '1234567891011121'; 
		$encryption_key = $this->pdobc_object->pdob_key;
		return openssl_encrypt($string, "AES-128-CTR", $encryption_key, 0, $encryption_iv); 
	}

	private function decrypt($string){
		$decryption_iv = '1234567891011121'; 
		$decryption_key = $this->pdobc_object->pdob_key; 
		return openssl_decrypt($string, "AES-128-CTR", $decryption_key, 0, $decryption_iv);
	}
}